<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <link href='https://fonts.googleapis.com/css?family=Architects+Daughter' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print">
    <script src="./build/p2.js"></script>
    <script src="./build/p2.renderer.js"></script>    
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <title>Chaos-pendulum by PubInv</title>
    </head>
    
    <style>
#table-wrapper {
  position:relative;
}
#table-scroll {
  height:100%;
  overflow:auto;  
  margin-top:20px;
}
#table-wrapper table {
  width:100%;

}
#table-wrapper table * {
  color:black;
}
#table-wrapper table thead th .text {
  position:absolute;   
  top:-20px;
  z-index:2;
  height:20px;
  width:35%;
  border:1px solid red;
}

.newtrace {
    color: red;
    font-size: large;
    background-color: yellow;
}
</style>
    
  <body>
    <header>
      <div class="inner">
        <h1>Chaos-pendulum</h1>
        <h2>An educational demonstration of the double pendulum producing chaos</h2>
        <a href="https://github.com/PubInv/chaos-pendulum" class="button"><small>View project on</small> GitHub</a>
      </div>
    </header>

    <div id="content-wrapper">
      <div class="inner clearfix">
        <section id="main-content">
    <section id="visualsection" style="{border: red;}">
    </section>
    <section id="textsection" style="{border: red;}">
    <button onclick="start_trial()">Start New Trial!</button>
    <button onclick="pause()">Pause</button>
    <button onclick="my_clear()">Clear Traces</button>
    <button onclick="toggle_sound()">Toggle Sound</button>        
    </section>
    
    <h1> Chaos! </h1>

    <h2>The Double Pendulum</h2>

The double pendulum is a pendulum hanging from a pendulum.  It is a simple physical system that exhibits
    <a href="https://en.wikipedia.org/wiki/Chaos_theory">mathematical chaos</a>. It is
very hard to tell where a double pendulum will be precisely in the futue, because even a tiny variation in where it
starts creates wild differences in where it will be later. A single pendulum is completely different. In fact a
single pendulum is so steady that it can be used as a clock.

    <h2> What you are Seeing </h2>
    The simulation you are seeing simulates both a single pendulum and a double pendulum for 20 seconds.
    The double pendulum draws a trace where its tip moves. We are comparing the trace to the last trace that was drawn out.
    When the trace moves away from the last one, we draw its value in yellow in the table on the right. Each new start of the both the double and single pendulm arms start with a slight random value added.  However, you can't really tell for the 
single pdendulum, because it doesn't matter.  However, it is very hard to get the double pendulum to go for a full 10 seconds
before being in a very different spot than the last trace.

    <h3> Motivation</h3>

<p>
The Chaos Pendulum webpage was developed by Robert L. Read and Martin Smith as a simulation of a physical exhibit
for the <a href="http://www.montshire.org/">Montshire Museum of Science</a>. It is not as highly parametrizable and
configurable as some other simulations you may find on the web.
</p>   

    <h3>Thanks to p2.js</h3>
    This simulation does not solve the equations of motion of the double pendulum directly, but rather uses the general
purpose two-dimensional physics engine <a href="https://schteppe.github.io/p2.js/">p2.js</a>.
    Thanks to Stefan Hedman for this wonderful software!
    
<h3>
<a id="authors-and-contributors" class="anchor" href="#authors-and-contributors" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Authors and Contributors</h3>

    <p><a href="https://github.com/PubInv/chaos-pendulum">Chaos Pendulum</a> is maintained by

<a href="mailto:read.robert@gmail.com">Robert L. Read</a> at <a href="https://github.com/PubInv">PubInv</a>.</p>

        </section>

        <aside id="sidebar">
<div id="table-wrapper">
  <div id="table-scroll">
    <table id="trialtable">
     <tr>
    <th>Tick</th>
    <th>Time (s)</th>
    <th>Single (deg)</th>
    <th>Double (deg)</th>
    <th>Double Pendulum Distance To Standard Trace (m)</th>    
    </tr>
    </table>
  </div>
</div>    
        </aside>
      </div>
    </div>


    <audio id="tick" src="http://www.soundjay.com/button/button-19.mp3"></audio>
    <audio id="tock" src="http://www.soundjay.com/button/button-29.mp3"></audio>
    <audio id="ding" src="http://www.soundjay.com/button/button-37.mp3"></audio>        
        <script>

/* TODO:

-- draw borders around the rectangles
-- Create the trace for the single pendulum and do the same computation there.
-- Allow everything to be parameterized.
-- Add a way to set the angles by handle.
-- Add a message banner!
-- Say "Weclome Rascally Rabbit!"
-- Create the bracelet motion exercise.


This stuff is harder:
-- Stop game when the trace is new and report "Congratulations, you found new trace never found before!" 
"It took X seconds".
-- need a way to store the traces

*/ 
    var w, h, canvas, ctx, circleBody;
var bodies = {};
var bgraphs = {};

// These time series will be used to compute the distance
var current_time_series = [];
var last_time_series = [];
var standard_time_series;

var renderer, stage, container, graphics, zoom,boxShape, boxBody, planeBody, planeShape;

// I THINK P2.js uses the KMS system of units.
var L = 1.0; // Let's assume a 1 meter length!!!
var L1 = L/2;
var L2 = L/3;

var DEGREES_OF_VARIATION = 4;

// This is meters!
var DIVERGENCE_DEFINITION = 0.4; 

var ANGULAR_DAMPING = 0.02; // (Between 1.0 and 0.0)
var LINEAR_DAMPING = 0.02; // (Between 1.0 and 0.0)
    
var origin = [0,0];
var SL = L*2;
var TL = 1.0;
var r1 = 6;
var r2 = 4;
var L1 = SL*TL*r1/(r1+r2); // First arm
var L2 = SL*TL*r2/(r1+r2); // Second arm

var initial_angle_deg = 70, // raise angle, ccw from x axis, in degrees.
    initial_angle = (initial_angle_deg/360) * 2.0 * Math.PI;

var hang_angle_deg = 270,
    hang_angle = (hang_angle_deg/360) * 2.0 * Math.PI;    

var single_arm_pos = [origin[0] + Math.cos(initial_angle)*SL/2 , origin[1] + Math.sin(initial_angle)*SL/2 ];

var d1_arm_pos = [origin[0] + Math.cos(initial_angle)*L1/2 , origin[1] + Math.sin(initial_angle)*L1/2 ];
var d2_arm_pos = [d1_arm_pos[0] + Math.cos(initial_angle)*L1/2 +  Math.cos(hang_angle)*(L2)/2,
		  d1_arm_pos[1] + Math.sin(initial_angle)*L1/2 +  Math.sin(hang_angle)*(L2)/2];

 var PLAYER = Math.pow(2,0),
                        SINGLE =  Math.pow(2,1),
                        DOUBLE = Math.pow(2,2)

var GRAVITY = -9.82;
// This is used to slow the system down for testing.
var GRAVITY_SLOWDOWN = 0.1;
var buttons = {
    space : false,
    left :  false,
    right : false,
}
var sarmBody;

var armBody;
var secondArmBody;

var world;
var dummyBody1;
var dummyBody2;

var initAngVel = 5;

var MAX_NUM_TICKS = 20;

var divergence_interval = [-1,[]];

function start_trial() {
    last_time_series = current_time_series;
    // Is this is the first one, record it as standard.
    if (!standard_time_series) {
	standard_time_series = last_time_series.slice();
    }
    current_time_series = [];
    var random_degree = Math.random() * DEGREES_OF_VARIATION - DEGREES_OF_VARIATION/2;
    var random_rads = (random_degree / 360) * 2.0 * Math.PI;
    reset_single_pendulum(random_rads);
    reset_double_pendulum(random_rads);
    firstTime = null;
    lastReportedTime = null;
    ticks = null;
    lastReportTime = null;
    paused = false;
    divergence_interval = [-1,[]];
}

function playSound (id) {
    if (sound_on)    
    document.getElementById(id).play();
}


var paused = false;
function pause() {
    paused = !paused;
    if (!paused) 
        requestAnimationFrame(animate);    
}
var sound_on = false;
function toggle_sound() {
    sound_on = !sound_on;
    if (!sound_on)
	playSound('ding');
}

function my_clear() {
    graphics.clear();
}

function random_color() {
    return '0x'+Math.floor(Math.random()*16777215).toString(16);
}

function gen_row(tick,time,s,d,closest) {
    return 
    "<tr>" +
	"</tr>";
}

function debug_time_series_distance(t1,t2) {
    for(var i = 0; i < Math.min(t1.length,t2.length); i++) {
	var a = t1[i][3];
	var b = t2[i][3];
	console.log("i = a, b : "+ i + " = " + a+" , " + b);
	console.log(distance(a,b));	
    }
}
// This could be replaced with a binary search
function get_value_from_time_series(ts,t) {
    for(var i = 0; i < ts.length; i++) {
	var entry = ts[i];
	if (entry[0] >= t) {
	    return entry;
	}
    }
    return null;
}


// Here is my attempt to develop an an online-algorithm for determining
// the point of divergence between two time series.
//
// inputs:
// ol - online time series which is growing.
// i -- the index of the point to test (probably the index of the last value in online in online usage)
// ts - the time series we are testing against.
// ds - a pair, consisting of the next index to process from, and an interval. the last region computed by diverge (i-1) (the empty set set at start).
// ds = [p,[start,finish]] --- p means the point p has start and finish interval.
// b -- the "bracelet" distance
// Note a region is an interval [j,k] where j is a contained member, but k is not.
// if j == k, there are not elmentes in the interval.
// An empty array [] corresponds to an interval with no elements.
// 
// 
// outputs:
// The regions (ds) for the new point.
//
function diverge(ol,i,ts,ds,b) {
    var p = ds[0];
    if ((ds[1].length == 0) && p >= 0) return ds;
    if (i >= ol.length) return ds;
    

    // This is weird, I should probably use an object instead of an array here..
    if (p < 0) p = 0;
    var ret = [];
    while(p <= i) {
	var x = ol[p][3][0];
	var y = ol[p][3][1];
	// first we advance the end of the interval as far as possible.
	var finish = (ds[1].length == 0) ? 0 : ds[1][1];
	var done = false;
	while(!done && finish < ts.length) {
	    var d = distance([x,y],ts[finish][3]);
	    if (d <= b) {
		finish++;
	    } else {
		done = true;
	    }
	}
	ret[1] = finish;
	// now adance the back of the interval as required.
	done = false;
    
	var start = (ds[1].length == 0) ? 0 : ds[1][0];
	var done = false;
	while(!done && start < finish) {
	    var d = distance([x,y],ts[start][3]);
	    if (d > b) {
		start++;
	    } else {
		done = true;
	    }
	}
	ds[1][0] = start;
	ds[1][1] = finish;
	ret[0] = p;
	ret[1] = [start,finish];
	p++;
    }
    if (ret[1][0] == ret[1][1]) {
	console.log(ret);
	console.log("returning nothing");
	return [p,[]];
    }
    console.log(ret);
    return ret;
}

Array.prototype.compare = function(testArr) {
    if (this.length != testArr.length) return false;
    for (var i = 0; i < testArr.length; i++) {
        if (this[i].compare) { 
            if (!this[i].compare(testArr[i])) return false;
        }
        if (this[i] !== testArr[i]) return false;
    }
    return true;
}



// Create two time series and see when they diverge.
function test_diverge0() {
    var t = [[0,null,null,[0,0]],
	     [1,null,null,[1,1]],
	     [2,null,null,[2,2]],
	     [3,null,null,[3,3]],
	     [4,null,null,[4,4]]	     
	    ];
    var s = [[0,null,null,[0,0]],
	     [1,null,null,[1.1,1.1]],
	     [2,null,null,[2.2,2.2]],
	     [3,null,null,[3.3,3.3]],
	     [4,null,null,[4.4,4.4]]	     
	    ];
    var ds = [-1,[]];
    var b = 0.3;
    var divergent = [];
    for(var i = 0; i < s.length; i++) {
	ds = diverge(s,i,t,ds,b);
	console.log(ds);
	if (ds[1].length == 0) {
	    divergent.push(i);
	}
    }
    if (divergent.compare([3,4])) {
	console.log("Success!");
    } else {
	console.log("Failure!");
    }
    
}

function tick(ticks,time) {
    add_row(ticks,time);
//    playSound('tick');    
}
function distance(v1,v2) {
    var dx = v1[0]-v2[0];
    var dy = v1[1]-v2[1];
    return Math.sqrt(dx*dx + dy*dy);
}
function add_row(ticks,time) {
    var table = document.getElementById("trialtable");
    var b = bodies["secondArmBody"];    
    // Note adding in Math.PI/2 here creates creates a system of positive degrees to the right, negative to the left, probably what we want...
    var s = (bodies["sarmBody"].angle + Math.PI/2) * 180 / Math.PI;
    var d = ( Math.PI/2 + Math.atan2(b.position[1],b.position[0]))*180/Math.PI;

    var row = table.insertRow(1);
    var cell1 = row.insertCell(0);
    var cell2 = row.insertCell(1);
    var cell3 = row.insertCell(2);
    var cell4 = row.insertCell(3);
    var cell5 = row.insertCell(4);
    cell1.innerHTML = ""+ticks;
    cell2.innerHTML = ""+time.toFixed(1);    
    cell3.innerHTML = ""+s.toFixed(0) ;
    cell4.innerHTML = ""+d.toFixed(0) ;

    var dist_string;
    var dist;
    var entry;
    if (standard_time_series 
	&&  (entry = get_value_from_time_series(standard_time_series,time))
       ) {
	var len = current_time_series.length;
	var cur = find_tip_of_second_arm(b);
	// NOTE: I should be able to use the vec2 library for this, but can't figure out how to include it!
        dist = distance(cur,entry[3]);
	divergence_interval = diverge(current_time_series,current_time_series.length-1,standard_time_series,
		     divergence_interval,DIVERGENCE_DEFINITION);
	dist_string = "" + dist.toFixed(2) + "m";
        if (!b.newtrace && divergence_interval[1].length > 0) {
	    var p = divergence_interval[0]; // this is on current_time_series
	    var start = divergence_interval[1][0];
	    var finish = divergence_interval[1][1];
	    console.log(" p start finish "+p+" , "+start + " , "+ finish);
/*
	    graphics.moveTo(current_time_series[p][0],current_time_series[p][1]);
    	    graphics.lineStyle(0.02,"0x000000");
	    graphics.lineTo(standard_time_series[start][0],standard_time_series[start][1]);

	    graphics.moveTo(current_time_series[p][0],current_time_series[p][1]);	    
	    graphics.lineStyle(0.02,"0x0000ff");
	    graphics.lineTo(standard_time_series[finish][0],standard_time_series[finish][1]);
*/
	}
    } else {
	dist = 0.0;
	dist_string = "NA";
    }
    
    cell5.innerHTML = ""+dist_string;
    //    if (dist >= DIVERGENCE_DEFINITION || b["newtrace"]) {
    if ((divergence_interval[1].length == 0) || b["newtrace"]) {
	if (standard_time_series) {
	    var x = 4;
	}
	b.color = "0xff0000";
	b["newtrace"] = true;
	row.setAttribute("class", "newtrace");
    }
    if (ticks >= MAX_NUM_TICKS) {
	start_trial();
    }
}

init();

requestAnimationFrame(animate);

function init_world() {
    world = new p2.World({
        gravity : [0,GRAVITY*GRAVITY_SLOWDOWN]
    });

    world.solver.iterations = 30;
    world.solver.tolerance = 0.01;

    // Create static dummy body that we can constrain other bodies to

    init_double_pendulum();
    init_single_pendulum();

}

function init(){

    init_world();
    // Pixi.js zoom level
    zoom = 150;

    var section = document.getElementById("visualsection");
    // Initialize the stage
    var w = section.offsetWidth;
    var h = section.offsetHeight;
    
    renderer =  PIXI.autoDetectRenderer(w, h),
    stage = new PIXI.Stage(0xFFFFFF);

    // We use a container inside the stage for all our content
    // This enables us to zoom and translate the content
    container =     new PIXI.DisplayObjectContainer(),
    
    stage.addChild(container);

    // Add the canvas to the DOM
    var section = document.getElementById("visualsection");
    section.appendChild(renderer.view);

    // Add transform to the container
    container.position.x =  renderer.width/2; // center at origin
    container.position.y =  renderer.height/2;
    container.scale.x =  zoom;  // zoom in
    container.scale.y = -zoom; // Note: we flip the y axis to make "up" the physics "up"


    // Draw the box.
    graphics = new PIXI.Graphics();

    add_bodies(container,bodies);
    // Add the box to our container
    container.addChild(graphics);
}

function add_bodies(container,bodies,graphics) {
    for (var key in bodies) {
	var b = bodies[key];
        // Draw the box.
        var g = new PIXI.Graphics();
	bgraphs[key] = g;
	g.beginFill(b.color);
	var w = b.shapes[0].width;
	var h = b.shapes[0].height;
	g.drawRect(-w/2, -h/2, w, h);
	container.addChild(g);
    }

}

function normalizeAngle(angle){
                        angle = angle % (2*Math.PI);
                        if(angle < 0){
                            angle += (2*Math.PI);
                        }
                        return angle;
}

function find_tip_of_second_arm(b) {
    var theta = normalizeAngle(b.angle);
    theta = normalizeAngle(theta);
    var len = L2/2;
    var pos = [b.position[0]+len*Math.cos(theta),b.position[1]+len*Math.sin(theta)];
    return pos;
}
function drawBodies(graphics,bs,gs) {
    for (var key in bodies) {
	var b = bodies[key];
	var g = gs[key];
	// Transfer positions of the physics objects to Pixi.js
	g.position.x = b.position[0];
	g.position.y = b.position[1];
	g.rotation =   b.angle;

	if (b.name == "secondArmBody") {
	    graphics.beginFill(b.color);
	    pos = find_tip_of_second_arm(b);
	    graphics.drawRect(pos[0], pos[1], 0.01, 0.01);	    
	}
    }
}

// all times in milliseconds, I guess.
var maxSubSteps = 5; // Max physics ticks per render frame
var fixedDeltaTime = 1 / 60; // Physics "tick" delta time
var lastReportedTime;
var lastTime;
var firstTime;
var ticks = 0;
var SOUND_ANGLE = 4.0;
var SOUND_ANGLE_SINGLE = 5.0;
// Animation loop
function animate(time){
    
    if (paused) return;
    
    time = time || 0;
    lastTime = lastTime || time;
    lastReportedTime = lastReportedTime || 0;
    firstTime = firstTime || time;

    // Now let us record the time series stuff....
    var s = (bodies["sarmBody"].angle + Math.PI/2) * 180 / Math.PI;
    var d = ( Math.PI/2 + Math.atan2(bodies["secondArmBody"].position[1],bodies["secondArmBody"].position[0]))*180/Math.PI;

    var b = bodies["secondArmBody"];
    var f = bodies["armBody"];    
    var pos = find_tip_of_second_arm(b);
    current_time_series.push([(lastTime-firstTime)/1000,s,d,[pos[0],pos[1]]]);

    // Now here is a little trick -- we will play a ding when the arm is close to full extension!!
    if (Math.abs(b.angle - f.angle) < SOUND_ANGLE*Math.PI/180) {
	playSound('ding');
    }

    // Now here is a little trick -- we will play a ding when the arm is close to full extension!!
    // Note that zero is downward here.
    if (Math.abs(s) < SOUND_ANGLE_SINGLE) {
	playSound('tock');
    }

    // Now compute the next step
    
    var deltaTime = lastTime ? (time - lastTime) / 1000 : 0;
    lastTime = time;

    if ((lastTime - lastReportedTime) >= 1000) {
	tick(ticks,(lastTime-firstTime)/1000);
	ticks++;
	lastReportedTime = lastTime;
    }
    // Make sure the time delta is not too big (can happen if user switches browser tab)
    deltaTime = Math.min(1 / 10, deltaTime);

    fixedDeltaTime = 1/60;
    // Move physics bodies forward in time
    world.step(fixedDeltaTime, deltaTime, maxSubSteps);

    drawBodies(graphics,bodies,bgraphs);
    // Render scene
    renderer.render(stage);
    
    requestAnimationFrame(animate);    
}

// Get current time, in seconds.
function time(){
    return new Date().getTime() / 1000;
}


function init_double_pendulum() 
{
    // Create arm

    // Create static dummy body that we can constrain other bodies to
    dummyBody2 = new p2.Body({
        mass: 0,
    });
    world.addBody(dummyBody2);
    
    var armShape =  new p2.Box({ width: L1, height: 0.1*L });
    armShape.collisionGroup = DOUBLE;            
    armBody = new p2.Body({
        mass: 2,
	position: [L1/2,0],
    });
    armBody.addShape(armShape,d1_arm_pos,initial_angle_deg);
    
    armBody.velocity = [0,0];
    
    armBody.angularVelocity = 0;
    

    armBody.name = "armBody";
    world.addBody(armBody);
    armBody.color =  "0xaaaaaa";

    bodies[armBody.name] = armBody;

    // Constrain it to the world
    var c = new p2.RevoluteConstraint(armBody, dummyBody2, {
        worldPivot: origin,
        collideConnected: false
    });

    world.addConstraint(c);

    // SecondArm
    var secondArmShape = new p2.Box({ width: L2, height: 0.1*L });
    armShape.collisionGroup = DOUBLE;            
    secondArmBody = new p2.Body({
        mass: 2,
	position: d2_arm_pos,
	angle: 0,
    });

    secondArmBody.velocity = [0,0];
    secondArmBody.angularVelocity = 0;    


    secondArmBody.addShape(secondArmShape);
    secondArmBody.name = "secondArmBody";
    secondArmBody.color = "0x333333";
    world.addBody(secondArmBody);

    bodies[secondArmBody.name] = secondArmBody;    

    // Connect secondArm to arm

    var c3 = new p2.RevoluteConstraint( armBody,secondArmBody, {
        localPivotA:
	    [L1/2 ,
	     0],
	localPivotB:
	[-L2/2,0],
        collideConnected: false
    });
    world.addConstraint(c3);
    
    armBody.angle = initial_angle;
    secondArmBody.angle = hang_angle;
    world.step(1/60);
    armBody.angle = initial_angle;
    secondArmBody.angle = hang_angle;
        world.step(1/60);
    armBody.angle = initial_angle;
    secondArmBody.angle = hang_angle;

    secondArmBody.angularDamping = ANGULAR_DAMPING;
    secondArmBody.damping = LINEAR_DAMPING;        

    armBody.angularDamping = ANGULAR_DAMPING;
    armBody.damping = LINEAR_DAMPING;        

    
}

function init_single_pendulum()
{
    dummyBody1 = new p2.Body({
        mass: 0,
    });
    world.addBody(dummyBody1);
    
    // Create arm
    var sarmShape =  new p2.Box({ width: SL, height: 0.1*L });
    sarmShape.collisionGroup = SINGLE;        
    sarmBody = new p2.Body({
        mass:4,
	position: single_arm_pos,
    });
    sarmBody.addShape(sarmShape);
    sarmBody.color =  "0x777777";
    sarmBody.name = "sarmBody";
    
    sarmBody.angle = initial_angle;
    
    world.addBody(sarmBody);

    bodies[sarmBody.name] = sarmBody; 
    
    // Constrain it to the world
    var c = new p2.RevoluteConstraint(sarmBody, dummyBody1, {
        worldPivot: origin,
        collideConnected: false
    });
    world.addConstraint(c);

    sarmBody.angle = initial_angle;
    sarmBody.velocity = [0,0];
    sarmBody.angularVelocity = 0;
    sarmBody.angularDamping = ANGULAR_DAMPING;
    sarmBody.damping = LINEAR_DAMPING;        
    
}

function reset_double_pendulum(random_rads)
{
    world.removeBody(armBody);
    world.removeBody(secondArmBody);    
    world.removeBody(dummyBody2);    
    init_double_pendulum();

    armBody.angle = initial_angle+random_rads;
    armBody.velocity = [0,0];
    armBody.angularVelocity = 0;
    armBody.angularDamping = ANGULAR_DAMPING;
    armBody.damping = LINEAR_DAMPING;        
    
    secondArmBody.angle = hang_angle;
    secondArmBody.velocity = [0,0];
    secondArmBody.angularVelocity = 0;
    secondArmBody.angularDamping = ANGULAR_DAMPING;
    secondArmBody.damping = LINEAR_DAMPING;            
    
    secondArmBody.color = random_color();
}

function reset_single_pendulum(random_rads)
{
    world.removeBody(sarmBody);
    world.removeBody(dummyBody1);    
    init_single_pendulum();
    
    armBody.angle = initial_angle+random_rads;
}

window.onkeydown = function(event){
    switch(event.keyCode){
    case 38: // up
    case 32: // space
        if(!buttons.space){
	    start_trial();
	    buttons.space = true;
        }
        break;
    case 39: // right
        buttons.right = true;
        break;
    case 37: // left
        buttons.left = true;
        break;
    }
}

window.onkeyup = function(event){
    switch(event.keyCode){
    case 38: // up
    case 32: // space
        buttons.space = false;
        break;
    case 39: // right
        buttons.right = false;
        break;
    case 37: // left
        buttons.left = false;
        break;
    }
}
    </script>

  
  </body>
</html>
